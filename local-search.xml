<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BP类攻击建模</title>
    <link href="/2026/01/20/BP%E7%B1%BB%E6%94%BB%E5%87%BB%E5%BB%BA%E6%A8%A1/"/>
    <url>/2026/01/20/BP%E7%B1%BB%E6%94%BB%E5%87%BB%E5%BB%BA%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Branch-Prediction-Attack"><a href="#Branch-Prediction-Attack" class="headerlink" title="Branch Prediction Attack"></a>Branch Prediction Attack</h1><h2 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h2><p><strong>BP 类攻击</strong> 指的是利用<strong>CPU 分支预测机制及其副作用</strong> 来泄露敏感信息或在隔离边界上建立侧信道的攻击。它属于一种<strong>微架构侧信道（microarchitectural side-channel）</strong>，常见的代表是<strong>Spectre 系列攻击</strong>。这些攻击不是针对软件算法错误，而是针对处理器预测逻辑和投机执行（speculative execution）的硬件行为。</p><p>核心思想：</p><ul><li>现代 CPU 为提高性能，会对条件分支&#x2F;间接跳转做预测，并投机执行路径。</li><li>如果预测错误，CPU 会回滚架构状态，但 微架构状态（如缓存）可能已被改变。</li><li>攻击者能通过对这些副作用的测量（例如缓存命中时间）来推断敏感数据。</li></ul><hr><h2 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h2><h3 id="攻击目标"><a href="#攻击目标" class="headerlink" title="攻击目标"></a>攻击目标</h3><table><thead><tr><th>目标类型</th><th>例子</th></tr></thead><tbody><tr><td>机密数据泄露</td><td>进程内密钥、用户密码、其他内存内容</td></tr><tr><td>跨进程&#x2F;跨 VM 数据泄露</td><td>虚拟化场景下的邻居 VM 隐私泄露</td></tr><tr><td>沙盒环境绕过</td><td>浏览器 JavaScript 利用 Spectre 读取内核&#x2F;其他进程数据</td></tr></tbody></table><h3 id="攻击者能力假设"><a href="#攻击者能力假设" class="headerlink" title="攻击者能力假设"></a>攻击者能力假设</h3><p>BP 类攻击通常假设攻击者可以：</p><ul><li>在同一处理器核心或共享预测器资源上执行代码；</li><li>构造特定模式的分支历史输入；</li><li>测量系统行为变化（如 cache timing）；</li><li>在某些场景下无需内核权限（pure JavaScript 也可利用）。</li></ul><p>这种能力模型类似于一种“<strong>白盒微架构侧信道访问</strong>”，不需要直接访问内存内容本身。</p><h3 id="抽象模型"><a href="#抽象模型" class="headerlink" title="抽象模型"></a>抽象模型</h3><p>BP 攻击可以抽象为以下四个阶段：</p><p><strong>① 污染&#x2F;训练分支预测器（Branch Predictor Training）</strong></p><p>攻击代码通过精心构造的分支序列来“训练”分支预测器，使其偏向某一分支方向。</p><p>→ 目的是在真实 victim 代码执行期间造成错误预测。</p><p><strong>② 触发投机执行（Speculative Execution）</strong></p><p>当 victim 代码遇到分支时，由于预测器的状态“被污染”，CPU 会错误预测路径并投机执行错误路径。</p><p>投机路径可能会读取敏感数据（本来不会发生的读取）。</p><p><strong>③ 留下微架构泄露（Microarchitectural Side Effects）</strong></p><p>错误路径的执行影响 CPU 微架构状态，如加载缓存某些行，改变分支历史缓冲器等。</p><p>这些状态并不被体系结构回滚机制撤销，因此可以被外部可测量。</p><p><strong>④ 侧信道测量与推断（Side-Channel Observation）</strong></p><p>攻击者测量缓存访问时间、分支预测历史等，从这些统计量恢复敏感数据。例如，时间差异表明某个缓存行被 victim 访问过，从而反推 secret value。</p><hr><h2 id="常见BP攻击"><a href="#常见BP攻击" class="headerlink" title="常见BP攻击"></a>常见BP攻击</h2><table><thead><tr><th>攻击类型</th><th>攻击原理</th><th>关键副作用</th></tr></thead><tbody><tr><td><strong>Spectre V2</strong></td><td>间接分支预测污染 (Branch Target Injection)</td><td>错误返回目标 $→ speculative\space path$ 执行</td></tr><tr><td><strong>分支历史注入（BHI）</strong></td><td>利用分支历史表（BHB）污染预测</td><td>注入错误历史，引导误预测</td></tr><tr><td><strong>BiasScope &#x2F; Spectre-BHS</strong></td><td>利用不准确的分支历史</td><td>二级侧信道泄露更高带宽信息</td></tr></tbody></table><h2 id="BP攻击系统模型"><a href="#BP攻击系统模型" class="headerlink" title="BP攻击系统模型"></a>BP攻击系统模型</h2><h3 id="建模目标"><a href="#建模目标" class="headerlink" title="建模目标"></a>建模目标</h3><p>零泄露：</p><p>$ I(Secret;Observation)&#x3D;0 $</p><p>或 可控泄露上界:</p><p>$ I(Secret;Observation)≤ε $</p><p>或 不可达性：</p><p>在防御机制下，投机路径永远无法访问 <strong>secret-dependent memory</strong></p><h3 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h3><p><strong>1.系统状态定义（Minimal State）</strong></p><p>我们定义系统在任意时刻的状态为：</p><p>$ S&#x3D;(A,B,M) $</p><p>其中：</p><ul><li><strong>A：架构可见状态（寄存器、PC）</strong></li><li><strong>B：分支预测器状态</strong></li><li><strong>M：缓存状态（或更一般的 microarchitectural state）</strong></li></ul><p><strong>2.程序模型（Victim + Attacker）</strong></p><p>Victim 程序抽象为：</p><p>$ if\space ϕ(x)\space then\space P_{safe}\space else\space P_{secret}​ $</p><ul><li>x：攻击者可控输入</li><li>𝜙(𝑥)：边界检查</li><li>$P_{secret}$：包含对 secret s 的访问（在架构语义下不可达）</li></ul><h3 id="投机执行的形式化定义"><a href="#投机执行的形式化定义" class="headerlink" title="投机执行的形式化定义"></a>投机执行的形式化定义</h3><p>定义一个投机转移关系：</p><p>$ (B,A) \xrightarrow{spec} A’ $</p><p>即：</p><ul><li>预测器状态 $B$ 决定下一条路径</li><li>即使 $ϕ(x)&#x3D;false$，仍可能执行 $P_{secret}$​</li></ul><h3 id="泄露唯一来源"><a href="#泄露唯一来源" class="headerlink" title="泄露唯一来源"></a>泄露唯一来源</h3><p>我们定义：</p><ul><li>唯一可被攻击者观测的量是：<br>$ O &#x3D; f(M) $</li></ul><p>攻击者不能直接观测 $A$ 或 $B$，只能观测泄露状态 $O$(例如 cache timing)</p><h3 id="攻击成功的定义"><a href="#攻击成功的定义" class="headerlink" title="攻击成功的定义"></a>攻击成功的定义</h3><p>攻击成功 ⇔</p><p>$ I(s;O)&gt;0 $</p><p>也即：</p><p>$ P(O∣s&#x3D;s1​) \neq P(O∣s&#x3D;s2​) $</p><h3 id="攻击证明"><a href="#攻击证明" class="headerlink" title="攻击证明"></a>攻击证明</h3><p>在无防御时：</p><p>1.存在 $B$ 使得：</p><p>$ ϕ(x)&#x3D;false∧(B,A)\xrightarrow{spec}​P_{secret} $​</p><p>2.$P_{secret}$中存在：</p><p>$M←g(s)$</p><p>3.因此：</p><p>$O&#x3D;f(M)&#x3D;f(g(s))$</p><p>⇒</p><p>$I(s;O)&gt;0$</p><h2 id="防御策略的形式化建模"><a href="#防御策略的形式化建模" class="headerlink" title="防御策略的形式化建模"></a>防御策略的形式化建模</h2><p><strong>防御策略 D：投机不可达性（Speculative Non-Interference, SNI）</strong></p><p>防御定义（形式化）</p><p>防御 D 保证：</p><p><strong>任意投机执行路径中，不允许 secret-dependent memory access</strong></p><p>形式化为：</p><p>$ \forall spec\space path\space π, \frac {\delta M}{\delta \space s} &#x3D; 0$</p><p>或更直观地：</p><p>$M_{after\space spec}​⊥s$</p><h3 id="防御有效性证明"><a href="#防御有效性证明" class="headerlink" title="防御有效性证明"></a>防御有效性证明</h3><p><strong>定理（SNI ⇒ 零泄露）</strong></p><p>若系统满足 <strong>Speculative Non-Interference</strong>，则：</p><p>$I(s;O)&#x3D;0$</p><p>证明：</p><p>1.攻击者的观测量：</p><p>$O&#x3D;f(M)$</p><p>2.根据防御假设：</p><p>$M⊥s$</p><p>3.因此：</p><p>$P(M∣s)&#x3D;P(M)$</p><p>4.由于 $O$ 是 $M$ 的确定性或随机函数：</p><p>$P(O∣s)&#x3D;\sum_M P(O∣M)P(M∣s)&#x3D;\sum_M P(O∣M)P(M)&#x3D;P(O)$</p><p>5.得证：</p><p>$I(s;O)&#x3D;0$</p><h3 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h3><p><strong>如果 $I \neq 0$，可以建模：有概率 $p$ 访问 secret，有噪声 $σ$</strong>    </p><p>可以推导：</p><p>$I(s;O)≤H(p)−H(p∣σ)$</p><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><h3 id="BiasScope-Spectre-BHS"><a href="#BiasScope-Spectre-BHS" class="headerlink" title="BiasScope &#x2F; Spectre-BHS"></a><a href="https://doi.org/10.48550/arXiv.2506.07263">BiasScope &#x2F; Spectre-BHS</a></h3><p>根据论文攻击流程（例如 BiasScope）：</p><ul><li>攻击者训练或置入某个分支状态 (Bias-Free BHB 条目)</li><li>Victim 执行某个 secret-dependent 分支</li><li>攻击者验证 BHB 是否被更新（或被驱逐）</li><li>从 BHB 记录状态的变化间接推断 secret 值（例如分支是否 taken）</li></ul><p>这说明：</p><ul><li><p>投机历史 $B$ 会依赖 $s$（victim secret branch 状态会修改 BHB）</p></li><li><p>这种修改又会被攻击者通过后续分支行为产生的微结构影响 $M$（比如缓存时间差）</p></li></ul><p>因此模型中的攻击链路存在：</p><p>$s→B→M→O$</p><p>即：</p><p>1.Victim secret 影响 BHB 状态</p><p>2.攻击者通过自身的推测执行利用 BHB 干扰预测路径</p><p>3.推测执行泄露副作用到缓存／时序</p><p>4.攻击者测量观察到不同的 $𝑂$，从而间接泄露 $s$</p><p><strong>为了证明攻击有效，需要证明：</strong>    </p><p>$I(s;O)&gt;0$</p><p>说明：</p><p>不同 secret $s_1,s_2$对 BHB 更新有不同概率或不同最终状态</p><p>该差异通过 $f(M)$ 被攻击者测量捕获（cache 时序）</p><p>例如在 BiasScope 中：</p><p>Victim 分支 taken 会 evict／update 特定 BHB 条目</p><p>攻击者随后执行自己的分支序列<br>→ 会因 BHB 差异导致预测行为不同<br>→ 侧信道可测量（如 mis-prediction 计数、cache 影响等）</p><p>因此可以构造：</p><p>$P(O∣s_1​) \neq P(O∣s_2​)$</p><p>从而：</p><p>$I(s;O)&gt;0$</p><p><strong>防御目标</strong></p><p>防御策略目标是打断这个链条的一环使得：$s→(防御)→M$ 不成立或可控。</p><h3 id="IBT"><a href="#IBT" class="headerlink" title="IBT"></a>IBT</h3><p>IBT 的硬件语义可以抽象为以下不变式：</p><p>$\qquad$<strong>任意间接跳转 &#x2F; 间接调用的投机目标，必须是合法 ENDBR 入口</strong></p><p>形式化定义：</p><p>令：</p><ul><li>$𝑇_{BTB}$：预测器给出的目标</li><li>$T_{legal}$：所有以 ENDBR 开头的地址集合</li></ul><p>IBT 强制：</p><p>$T_{spec}​∈T_{BTB}​∩T_{legal}$</p><p>否则：</p><p><strong>speculative execution aborts</strong></p><p><strong>防御目标</strong></p><p>IBT <strong>不改变预测器 𝐵，但约束预测器对架构状态 𝐴 的影响函数：</strong></p><p>$(B,A) \xrightarrow{spec} A’被限制$</p><p>变为：</p><p>$(B,A)\xrightarrow{spec} A’\space if\space PC(A’)\space∈\space T_{legal}​$</p><p><strong>IBT 阻断 BTB-based Spectre-V2</strong></p><p>证明：</p><p>1.攻击成立的必要条件是存在 gadget 𝐺，使得：</p><p>$PC_{spec}​&#x3D;G$</p><p>2.IBT强制：</p><p>$PC_{spec}​∈T_{legal}​$</p><p>3.若$G\notin T_{legal}$，则：</p><p>$(B,A)\nrightarrow A_{spec}’​$</p><p>4.因此不存在：</p><p>$s→M$</p><p>5.即：</p><p>$P(O∣s)&#x3D;P(O)⇒I(s;O)&#x3D;0$</p><p><strong>IBT 的“证明边界”</strong></p><p>IBT 仅证明：</p><ul><li>阻断 BTB-target injection</li><li>阻断 Spectre-V2 gadget 跳转</li></ul><p>但 不能证明：</p><ul><li>Branch History Side-Channel</li><li>条件分支投机（Spectre-V1）</li></ul><p>因为：</p><p>$s→B→M$ 仍可能成立（IBT 不隔离 B）</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
